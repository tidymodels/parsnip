#' Knit engine-specific documentation
#' @param pattern A regular expression to specify which files to knit. The
#' default knits all engine documentation files.
#' @return A tibble with column `file` for the file name and `result` (a
#' character vector that echos the output file name or, when there is
#' a failure, the error message).
#' @keywords internal
#' @export
knit_engine_docs <- function(pattern = NULL) {
  rmd_files <- list.files("man/rmd", pattern = "\\.Rmd", full.names = TRUE)

  if (!is.null(pattern)) {
    target_exists <- grepl(pattern, rmd_files)
    files <- rmd_files[target_exists]
  } else {
    files <- rmd_files[!grepl("(template-)|(setup\\.)", rmd_files)]
  }
  outputs <- gsub("Rmd$", "md", files)

  res <- purrr::map2(files, outputs, ~ try(knitr::knit(.x, .y), silent = TRUE))
  res <- purrr::map_chr(res, as.character)
  tibble::tibble(file = basename(files), result = res)
}

# TODO
# - In Rmd, state which packages have engine code e.g. "The parsnip package
#   contains rpart engines for classification and regression and the censored package
#   contains an rpart engine for censored regression".

# ------------------------------------------------------------------------------

extensions <- function() {
  c("baguette", "censored", "discrim", "multilevelmod", "plsmod",
    "poissonreg", "rules")
}

# ------------------------------------------------------------------------------

#' Save information about models
#' @description
#' This function writes a tab delimited file to the package to capture
#' information about the known models. This information includes packages in
#' the tidymodels GitHub repository as well as packages that are know to work
#' well with tidymodels packages (e.g. \pkg{tune}, etc.). There are likely
#' other model definitions in other extension packages that are not included
#' here that do not follow the
#' [model implementation guidelines](https://tidymodels.github.io/model-implementation-principles)
#' or do not work with packages other than \pkg{parsnip}.
#'
#' These data are used to document engines for each model function man page.
#' @keywords internal
#' @param path A character string for the location of the tab delimited file.
#' @details
#' It is highly recommended that the know parsnip extension packages are loaded.
#' The unexported \pkg{parsnip} function `extensions()` will list these.
#' @export
update_model_info_file <- function(path = "inst/models.tsv") {
  mods <- get_from_env("models")
  info <-
    purrr::map_dfr(mods, ~ get_from_env(.x) %>% dplyr::mutate(model = .x)) %>%
    dplyr::arrange(model, mode, engine) %>%
    dplyr::select(model, mode, engine)
  exts <-
    purrr::map_dfr(
      mods,
      ~ get_from_env(paste0(.x, "_pkgs")) %>% dplyr::mutate(model = .x)
    ) %>%
    tidyr::unnest(cols = "pkg") %>%
    dplyr::inner_join(tibble::tibble(pkg = extensions()), by = "pkg")

  info <- dplyr::left_join(info, exts, by = c("model", "engine"))

  csv <- utils::write.table(info, file = path, row.names = FALSE, sep = "\t")
  invisible(info)
}

# ------------------------------------------------------------------------------


#' Tools for dynamically documenting packages
#'
#' @description
#' These are functions used to create dynamic documentation in Rd files
#' based on which parsnip-related packages are loaded by the user.
#'
#' These functions can be used to make dynamic lists of documentation help
#'  files. \pkg{parsnip} uses these along with files in `man/rmd` which
#'  contain expanded documentation for specific model/engine combinations.
#'  [find_engine_files()] looks for files that have the pattern
#'  `details_{model}_{engine}.Rd` to link to. These files are generated by files
#'  named `man/rmd/{model}_{engine}.Rmd`. `make_engine_list()` creates a
#'  list seen at the top of the model Rd files while `make_seealso_list()`
#'  populates the list seen in "See Also" below. See the details section.
#'
#' @param mod A character string for the model file (e.g. "linear_reg")
#' @param pkg A character string for the package where the function is invoked.
#' @return
#' `make_engine_list()` returns a character string that creates a
#' bulleted list of links to more specific help files.
#'
#' `make_seealso_list()` returns a formatted character string of links.
#'
#' `find_engine_files()` returns a tibble.
#' @details
#' The \pkg{parsnip} documentation is generated _dynamically_. Part of the Rd
#'  file populates a list of engines that depends on what packages are loaded
#'  *at the time that the man file is loaded*. For example, if
#'  another package has a new engine for `linear_reg()`, the
#'  `parsnip::linear_reg()` help can show a link to a detailed help page in the
#'  other package.
#'
#' To enable this, the process for a package developer is to:
#'
#'   1. Create an engine-specific R file in the `R` directory with the name
#'  `{model}_{engine}.R` (e.g. `boost_tree_C5.0.R`). This has a small amount of
#'  documentation, as well as the directives "`@name details_{model}_{engine}`"
#'  and "`@includeRmd man/rmd/{model}_{engine}.md details`".
#'
#'   2. Copy the file in \pkg{parsnip} that is in `man/rmd/setup.Rmd` and put
#'  it in the same place in your package.
#'
#'   3. Write your own `man/rmd/{model}_{engine}.Rmd` file. This can include
#'  packages that are not listed in the DESCRIPTION file. Those are only
#'  required when the documentation file is created locally (probably using
#'  [devtools::document()]).
#'
#'   4. Run [devtools::document()] so that the Rmd content is included in the
#'  Rd file.
#'
#' The examples in \pkg{parsnip} can provide guidance for how to organize
#' technical information about the models.
#' @name doc-tools
#' @keywords internal
#' @export
#' @examples
#' find_engine_files("linear_reg")
#' cat(make_engine_list("linear_reg"))
find_engine_files <- function(mod) {
  # Get available topics
  topic_names <- find_details_topics(mod)
  if (length(topic_names) == 0) {
    return(character(0))
  }

  # Subset for our model function
  prefix <- paste0("parsnip:details_", mod, "_")
  eng <- gsub(prefix, "", topic_names)
  eng <- tibble::tibble(engine = eng, topic = topic_names)

  # Determine and label default engine
  default <- get_default_engine(mod)
  eng$default <- ifelse(eng$engine == default, cli::symbol$sup_1, "")

  # reorder based on default and name
  non_defaults <- dplyr::filter(eng, default == "")
  non_defaults <-
    non_defaults %>%
    dplyr::arrange(tolower(engine)) %>%
    dplyr::mutate(.order = dplyr::row_number() + 1)
  eng <-
    dplyr::filter(eng, default != "") %>%
    dplyr::mutate(.order = 1) %>%
    dplyr::bind_rows(non_defaults)

  eng
}

#' @export
#' @rdname doc-tools
make_engine_list <- function(mod) {
  eng <- find_engine_files(mod)

  if (length(eng) == 0) {
    return(
      paste(
        "There are different ways to fit this model. The method of estimation is ",
        "chosen by setting the model \\emph{engine}. No engines were found for ",
        "this model.\n\n"
      )
    )
  } else {
    main <- paste(
      "There are different ways to fit this model. The method of estimation is ",
      "chosen by setting the model \\emph{engine}. The engine-specific pages ",
      "for this model are listed  below.\n\n"
    )
  }

  exts <-
    utils::read.delim(system.file("models.tsv", package = "parsnip")) %>%
    dplyr::filter(model == mod) %>%
    dplyr::group_by(engine) %>%
    dplyr::summarize(extensions = sum(!is.na(pkg))) %>%
    dplyr::mutate(
      has_ext = ifelse(extensions > 0, cli::symbol$sup_2, "")
    )
  eng <- dplyr::left_join(eng, exts, by = "engine")


  eng <-
    eng %>%
    dplyr::arrange(.order) %>%
    dplyr::mutate(
      item = glue::glue("  \\item \\code{\\link[|topic|]{|engine|}|default||has_ext|}",
                        .open = "|", .close = "|")
    ) %>%
    dplyr::distinct(item)

  notes <- paste0("\n", cli::symbol$sup_1, " The default engine.")
  if (any(exts$has_ext != "")) {
    notes <- paste0(notes, " ", cli::symbol$sup_2, " May require a parsnip extension package.")
  }


  items <- glue::glue_collapse(eng$item, sep = "\n")
  res <- glue::glue("|main|\n\\itemize{\n|items|\n}\n\n |notes|",
                    .open = "|", .close = "|")
  res
}

get_default_engine <- function(mod, pkg = "parsnip") {
  cl <- rlang::call2(mod, .ns = pkg)
  rlang::eval_tidy(cl)$engine
}

#' @export
#' @rdname  doc-tools
make_seealso_list <- function(mod, pkg= "parsnip") {
  requireNamespace(pkg, quietly = TRUE)
  eng <- find_engine_files(mod)

  main <- c("\\code{\\link[=fit.model_spec]{fit()}}",
            "\\code{\\link[=set_engine]{set_engine()}}",
            "\\code{\\link[=update]{update()}}")

  if (length(eng) == 0) {
    return(paste0(main, collapse = ", "))
  }

  res <-
    glue::glue("\\code{\\link[|eng$topic|]{|eng$engine| engine details}}",
               .open = "|", .close = "|")

  if (pkg != "parsnip") {
    main <- NULL
  }
  paste0(c(main, res), collapse = ", ")
}

find_details_topics <- function(mod, pkg = "parsnip") {
  meta_loc <- system.file("Meta/Rd.rds", package = pkg)
  meta_loc <- meta_loc[meta_loc != ""]
  if (length(meta_loc) > 0) {
    topic_names <- readRDS(meta_loc)$Name
    res <- grep(paste0("details_", mod), topic_names, value = TRUE)
    if (length(res) > 0) {
      res <- paste0(pkg, ":", res)
    }
  } else {
    res <- character(0)
  }
  unique(res)
}

# For use in `set_engine()` docs
generate_set_engine_bullets <- function() {
  env <- get_model_env()
  models <- env$models
  info <- rlang::env_get_list(env, models)

  model_engines <- purrr::map(info, get_sorted_unique_engines)

  model_prefixes <- glue::glue(
    "\\code{\\link[=.{models}.]{.{models}.()}}:",
    .open = ".{",
    .close = "}."
  )

  bullets <- purrr::map2(
    .x = model_prefixes,
    .y = model_engines,
    .f = combine_prefix_with_engines
  )

  bullets <- glue::glue("\\item {bullets}")
  bullets <- glue::glue_collapse(bullets, sep = "\n")
  bullets <- paste("\\itemize{", bullets, "}", sep = "\n")

  bullets
}

sort_c <- function(x) {
  withr::with_collate("C", sort(x))
}
get_sorted_unique_engines <- function(x) {
  engines <- x$engine
  engines <- unique(engines)
  engines <- sort_c(engines)
  engines
}
combine_prefix_with_engines <- function(prefix, engines) {
  if (length(engines) == 0L) {
    engines <- "No engines currently available"
  } else {
    engines <- glue::glue_collapse(engines, sep = ", ")
  }

  glue::glue("{prefix} {engines}")
}

