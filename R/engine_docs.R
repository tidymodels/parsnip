#' Knit engine-specific documentation
#' @param pattern A regular expression to specify which files to knit. The
#' default knits all engine documentation files.
#' @return A tibble with column `file` for the file name and `result` (a
#' character vector that echos the output file name or, when there is
#' a failure, the error message).
#' @keywords internal
#' @export
knit_engine_docs <- function(pattern = NULL) {
  rmd_files <- list.files("man/rmd", pattern = "\\.Rmd", full.names = TRUE)

  if (!is.null(pattern)) {
    target_exists <- grepl(pattern, rmd_files)
    files <- rmd_files[target_exists]
  } else {
    files <- rmd_files[!grepl("(template-)|(setup\\.)", rmd_files)]
  }
  outputs <- gsub("Rmd$", "md", files)

  res <- purrr::map2(files, outputs, ~ try(knitr::knit(.x, .y), silent = TRUE))
  res <- purrr::map_chr(res, as.character)
  tibble::tibble(file = basename(files), result = res)
}

# TODO
# - In Rmd, state which packages have engine code e.g. "The parsnip package
#   contains rpart engines for classification and regression and the censored package
#   contains an rpart engine for censored regression".

# ------------------------------------------------------------------------------

extensions <- function(x) {
  c("baguette", "censored", "discrim", "multilevelmod", "plsmod",
    "poissonreg", "rules")
}

# ------------------------------------------------------------------------------


#' Tools for dynamically documenting packages
#'
#' @description
#' These are functions used to create dynamic documentation in Rd files
#' based on which parsnip-related packages are loaded by the user.
#'
#' These functions can be used to make dynamic lists of documentation help
#'  files. \pkg{parsnip} uses these along with files in `man/rmd` which
#'  contain expanded documentation for specific model/engine combinations.
#'  [find_engine_files()] looks for files that have the pattern
#'  `details_{model}_{engine}.Rd` to link to. These files are generated by files
#'  named `man/rmd/{model}_{engine}.Rmd`. `make_engine_list()` creates a
#'  list seen at the top of the model Rd files while `make_seealso_list()`
#'  populates the list seen in "See Also" below. See the details section.
#'
#' @param mod A character string for the model file (e.g. "linear_reg")
#' @param pkg A character string for the package where the function is invoked.
#' @return
#' `make_engine_list()` returns a character string that creates a
#' bulleted list of links to more specific help files.
#'
#' `make_seealso_list()` returns a formatted character string of links.
#'
#' `find_engine_files()` returns a tibble.
#' @details
#' The \pkg{parsnip} documentation is generated _dynamically_. Part of the Rd
#'  file populates a list of engines that depends on what packages are loaded
#'  *at the time that the man file is loaded*. For example, if
#'  another package has a new engine for `linear_reg()`, the
#'  `parsnip::linear_reg()` help can show a link to a detailed help page in the
#'  other package.
#'
#' To enable this, the process for a package developer is to:
#'
#'   1. Create an engine-specific R file in the `R` directory with the name
#'  `{model}_{engine}.R` (e.g. `boost_tree_C5.0.R`). This has a small amount of
#'  documentation, as well as the directives "`@name details_{model}_{engine}`"
#'  and "`@includeRmd man/rmd/{model}_{engine}.md details`".
#'
#'   2. Copy the file in \pkg{parsnip} that is in `man/rmd/setup.Rmd` and put
#'  it in the same place in your package.
#'
#'   3. Write your own `man/rmd/{model}_{engine}.Rmd` file. This can include
#'  packages that are not listed in the DESCRIPTION file. Those are only
#'  required when the documentation file is created locally (probably using
#'  [devtools::document()]).
#'
#'   4. Run [devtools::document()] so that the Rmd content is included in the
#'  Rd file.
#'
#' The examples in \pkg{parsnip} can provide guidance for how to organize
#' technical information about the models.
#' @name doc-tools
#' @keywords internal
#' @export
#' @examples
#' find_engine_files("linear_reg")
#' cat(make_engine_list("linear_reg"))
find_engine_files <- function(mod) {
  # Get available topics
  topic_names <- find_details_topics(mod)
  if (length(topic_names) == 0) {
    return(character(0))
  }

  # Subset for our model function
  eng <- strsplit(topic_names, "_")
  eng <- purrr::map_chr(eng, ~ .x[length(.x)])
  eng <- tibble::tibble(engine = eng, topic = topic_names)

  # Determine and label default engine
  default <- get_default_engine(mod)
  eng$default <- ifelse(eng$engine == default, " (default)", "")

  # reorder based on default and name
  non_defaults <- dplyr::filter(eng, !grepl("default", default))
  non_defaults <-
    non_defaults %>%
    dplyr::arrange(tolower(engine)) %>%
    dplyr::mutate(.order = dplyr::row_number() + 1)
  eng <-
    dplyr::filter(eng, grepl("default", default)) %>%
    dplyr::mutate(.order = 1) %>%
    dplyr::bind_rows(non_defaults)

  eng
}

#' @export
#' @rdname doc-tools
make_engine_list <- function(mod) {
  eng <- find_engine_files(mod)

  if (length(eng) == 0) {
    return("No engines were found for this model.\n\n")
  } else {
    modes <- get_from_env(paste0(mod, "_modes"))
    modes <- modes[modes != "unknown"]
    modes <- glue::glue_collapse(modes, sep = ", ", last = " and ")
    modes <- glue::glue("\\code{|mod|()} can fit |modes| models.",
                        .open = "|", .close = "|")
    main <- glue::glue("The engine-specific pages for this model are listed ",
                       "below. These contain further details:\n\n")
  }

  eng <-
    eng %>%
    dplyr::mutate(
      item = glue::glue("  \\item \\code{\\link[|topic|]{|engine|}|default|}",
                        .open = "|", .close = "|")
    ) %>%
    dplyr::distinct(item)

  items <- glue::glue_collapse(eng$item, sep = "\n")
  res <- glue::glue("|main|\n\\itemize{\n|items|\n}\n\n |modes|}",
                    .open = "|", .close = "|")
  res
}

get_default_engine <- function(mod, pkg = "parsnip") {
  cl <- rlang::call2(mod, .ns = pkg)
  rlang::eval_tidy(cl)$engine
}

#' @export
#' @rdname  doc-tools
make_seealso_list <- function(mod, pkg= "parsnip") {
  requireNamespace(pkg, quietly = TRUE)
  eng <- find_engine_files(mod)

  main <- c("\\code{\\link[=fit.model_spec]{fit()}}",
            "\\code{\\link[=set_engine]{set_engine()}}",
            "\\code{\\link[=update]{update()}}")

  if (length(eng) == 0) {
    return(paste0(main, collapse = ", "))
  }

  res <-
    glue::glue("\\code{\\link[|eng$topic|]{|eng$engine| engine details}}",
               .open = "|", .close = "|")

  if (pkg != "parsnip") {
    main <- NULL
  }
  paste0(c(main, res), collapse = ", ")
}

find_details_topics <- function(mod, pkg = "parsnip") {
  meta_loc <- system.file("Meta/Rd.rds", package = pkg)
  meta_loc <- meta_loc[meta_loc != ""]
  if (length(meta_loc) > 0) {
    topic_names <- readRDS(meta_loc)$Name
    res <- grep(paste0("details_", mod), topic_names, value = TRUE)
    if (length(res) > 0) {
      res <- paste0(pkg, ":", res)
    }
  } else {
    res <- character(0)
  }
  unique(res)
}

# For use in `set_engine()` docs
generate_set_engine_bullets <- function() {
  env <- get_model_env()
  models <- env$models
  info <- rlang::env_get_list(env, models)

  model_engines <- purrr::map(info, get_sorted_unique_engines)

  model_prefixes <- glue::glue(
    "\\code{\\link[=.{models}.]{.{models}.()}}:",
    .open = ".{",
    .close = "}."
  )

  bullets <- purrr::map2(
    .x = model_prefixes,
    .y = model_engines,
    .f = combine_prefix_with_engines
  )

  bullets <- glue::glue("\\item {bullets}")
  bullets <- glue::glue_collapse(bullets, sep = "\n")
  bullets <- paste("\\itemize{", bullets, "}", sep = "\n")

  bullets
}

sort_c <- function(x) {
  withr::with_collate("C", sort(x))
}
get_sorted_unique_engines <- function(x) {
  engines <- x$engine
  engines <- unique(engines)
  engines <- sort_c(engines)
  engines
}
combine_prefix_with_engines <- function(prefix, engines) {
  if (length(engines) == 0L) {
    engines <- "No engines currently available"
  } else {
    engines <- glue::glue_collapse(engines, sep = ", ")
  }

  glue::glue("{prefix} {engines}")
}

keep_ext <- function(x, pkgs) {
  x <- x[x %in% pkgs]
  if (length(x) > 0) {
    x <- paste0("\\pkg{", x, "}")
    x <- glue::glue_collapse(x, sep = ", ", last = " and ")
    x <- paste0(" (may require: ", x, ")")
  } else {
    x <- ""
  }
  x
}

get_extension_pkgs <- function(mod) {
  deps <-
    get_from_env(paste0(mod, "_pkgs")) %>%
    dplyr::mutate(ext = purrr::map_chr(pkg, keep_ext, parsnip:::extensions()))
  dplyr::select(deps, engine, ext)
}

#' @export
#' @rdname doc-tools
pkg_extension_note <- function(mod) {
  ext_pkgs <- tibble::tibble(pkg = parsnip:::extensions())
  deps <-
    get_from_env(paste0(mod, "_pkgs")) %>%
    tidyr::unnest(cols = c(pkg)) %>%
    dplyr::inner_join(ext_pkgs, by = "pkg") %>%
    dplyr::arrange(tolower(engine)) %>%
    dplyr::mutate(
      pkg = paste0("\\pkg{", pkg, "}"),
      engine = paste0("`", engine, "`")
      ) %>%
    dplyr::group_nest(pkg) %>%
    dplyr::mutate(note = purrr::map_chr(data, ~ glue::glue_collapse(.x$engine, sep = ", ", last = " and "))) %>%
    dplyr::mutate(note = glue::glue("Note that engine(s) {note} may require extension package {pkg}.\n\n")) %>%
    purrr::pluck("note")

  paste(deps, collapse = "")
}
